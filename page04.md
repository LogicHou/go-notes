# 04

## Go 的数据类型大体分为三种

* 基本数据类型 其中数值类型又用的最多
* 复合数据类型
* 接口类型

## 基本数据类型

### 广泛使用的整型

#### 平台无关整型

    有符号整形
    ├── [类型] [长度]  [取值范围]
    ├── int8  1个字节 [-128, 127]
    ├── int16 2个字节 [-32768, 32767]
    ├── int32 4个字节 [-2147483648, 2147483647]
    └── int64 8个字节 [-9223372036854775808, 9223372036854775807]
    
    无符号整形
    ├── [类型] [长度]  [取值范围]
    ├── uint8  1个字节 [0, 255]
    ├── uint16 2个字节 [0, 65535]
    ├── uint32 4个字节 [0, 4294967295]
    └── uint64 8个字节 [0, 1844674407370955165]

#### 平台相关整型

可以通过 unsafe 包提供的 SizeOf 函数来获取

    unsafe.Sizeof(var)

    平台相关整型
    ├── [类型]                  [32位长度]   [64位长度]
    ├── 默认的有符号整形 int      32位(4字节)  64位(8字节)
    ├── 默认的无符号整形 uint     32位(4字节)  64位(8字节)
    ├── 无符号整形      uintptr  大到足以存储任意一个指针的值
    └── 有移植性要求的代码，不要强依赖这些类型的长度

#### 整型的溢出问题

如果因为参与某个运算，导致结果超出了某个整型类型的值边界，就会产生整型溢出的问题

由于整型无法表示它溢出后的那个“结果”，所以出现溢出情况后，对应的整型变量的值依然会落到它的取值范围内

    var s int8 = 127
    s += 1 // 预期128，实际结果-128

    var u uint8 = 1
    u -= 2 // 预期-1，实际结果255

#### 字面值与格式化输出

    a := 53        // 十进制
    b := 0700      // 八进制，以"0"为前缀
    c1 := 0xaabbcc // 十六进制，以"0x"为前缀
    c2 := 0Xddeeff // 十六进制，以"0X"为前缀

    # go version >= 1.13
    d1 := 0b10000001 // 二进制，以"0b"为前缀
    d2 := 0B10000001 // 二进制，以"0B"为前缀
    e1 := 0o700      // 八进制，以"0o"为前缀
    e2 := 0O700      // 八进制，以"0O"为前缀
    # 使用分隔符“_”提高可读性
    a := 5_3_7   // 十进制: 537
    b := 0b_1000_0111  // 二进制位表示为10000111 
    c1 := 0_700  // 八进制: 0700
    c2 := 0o_700 // 八进制: 0700
    d1 := 0x_5c_6d // 十六进制：0x5c6d

    # 输出格式
    var a int8 = 59
    fmt.Printf("%b\n", a) //输出二进制：111011
    fmt.Printf("%d\n", a) //输出十进制：59
    fmt.Printf("%o\n", a) //输出八进制：73
    fmt.Printf("%O\n", a) //输出八进制(带0o前缀)：0o73
    fmt.Printf("%x\n", a) //输出十六进制(小写)：3b
    fmt.Printf("%X\n", a) //输出十六进制(大写)：3B

### 浮点型

采用 [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 标准

Go 语言提供了 float32 与 float64 两种浮点类型，分别对应 IEEE 754 中的单精度与双精度浮点数值类型(都是平台无关的)

默认值都为 0.0 ，但是占用的内存空间大小不一样

IEEE 754 规范中存储和表示一个浮点数的标准形式，在内存中的二进制表示分三个部分：符号位、阶码（即经过换算的指数）

阶码和尾数的长度决定了浮点类型可以表示的浮点数范围与精度

日常中使用双精度浮点类型（float64）的情况更多，这也是 Go 语言中浮点常量或字面值的默认类型

#### 字面值与格式化输出

直白型：

    3.1415
    .15  // 整数部分如果为0，整数部分可以省略不写
    81.80
    82. // 小数部分如果为0，小数点后的0可以省略不写

科学计数法：

    # 十进制科学计数法
    6674.28e-2 // 6674.28 * 10^(-2) = 66.742800
    .12345E+5  // 0.12345 * 10^5 = 12345.000000
    
    # 十六进制科学计数法
    0x2.p10  // 2.0 * 2^10 = 2048.000000
    0x1.Fp+0 // 1.9375 * 2^0 = 1.937500

fmt输出形式是通过 %f ：

    var f float64 = 123.45678
    fmt.Printf("%f\n", f) // 123.456780

    # 科学计数法
    fmt.Printf("%e\n", f) // 1.234568e+02
    fmt.Printf("%x\n", f) // 0x1.edd3be22e5de1p+06

### 复数类型

Go 提供两种复数类型

* complex64   实部与虚部都是 float32 类型
* complex128  实部与虚部都是 float64 类型
* 默认赋值类型为 complex128

#### 字面值

    var c = 5 + 6i
    var d = 0o123 + .12345E+5i // 83+12345i

    # 通过函数
    var c = complex(5, 6) // 5 + 6i
    var d = complex(0o123, .12345E+5) // 83+12345i

    # 通过 real 和 imag 获取一个复数的实部与虚部，返回一个浮点类型值
    var c = complex(5, 6) // 5 + 6i
    r := real(c) // 5.000000
    i := imag(c) // 6.000000

### 创建自定义的数值类型

可以通过 type 关键字基于原生数值类型来声明一个新类型

虽然新类型的数值性质与 int32 完全相同(同底层类型)，但仍是两种完全不同的类型，无法直接相互赋值

    type MyInt int32
    
    var m int = 5
    var n int32 = 6
    var a MyInt = m // 错误：在赋值中不能将m（int类型）作为MyInt类型使用
    var a MyInt = n // 错误：在赋值中不能将n（int32类型）作为MyInt类型使用

通过显式转换，让赋值操作符左右两边的操作数保持类型一致，才能进行赋值：

    var m int = 5
    var n int32 = 6
    var a MyInt = MyInt(m) // ok
    var a MyInt = MyInt(n) // ok

### 类型别名（Type Alias）

和 type 语法不同，通过类型别名语法定义的新类型与原类型完全等价，可以完全相互替代

不再需要显式转型，就可以相互赋值：

    type MyInt = int32

    var n int32 = 6
    var a MyInt = n // ok

### 字符串类型 string

Go 原生支持字符串

#### string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率

    var s string = "hello"
    s[0] = 'k'   // 错误：字符串的内容是不可改变的
    s = "gopher" // ok

#### 没有结尾’\0’，而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销

Go 获取字符串长度是一个常数级时间复杂度，无论字符串中字符个数有多少，都可以快速得到字符串的长度值

#### 原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担

反引号原生支持构造“所见即所得”的原始字符串，原始字符串中的任意转义字符都不会起到转义的作用

    var s string = `line1
        line2
        line3`
    fmt.Println(s)